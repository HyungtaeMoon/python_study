`기본기` `정리`

### 파이썬

- 공부하면서 필요하다고 생각하는 내용들을 정리

- 머리속에 코드가 돌아가는걸 시각적으로 생각하기
    - 시각적으로 되는게 힘들면 각 기능에 대해 최대한 이해하고 외우기

1. 파이썬과 함께하는 자료구조

- 리스트
    - 선형 리스트
    - 연결 리스트
        - 단순 연결 리스트
        - 이중 연결 리스트
        - 원형 연결 리스트
- 스택
    - 뒤로가기, Ctrl + Z 기능, 미로찾기(오른손 법칙)
- 큐
    - 운영체제의 작업 스케줄링, 콜 센터 전화 서비스, 이진트리의 레벨 순회, 그래프의 너비우선탐색 등
- 데크 - (스택 + 큐) 양쪽에서 삽입, 삭제 가능
    - 스크롤, 문서 편집기의 undo 연산, 웹 브라우저의 방문기록
- 트리 - 계층적 자료구조로서 파이썬 리스트나 연결리스트의 단점을 보완하는 자료구조
    - 이진트리(전위, 중위, 후위는 스택 자료구조를 사용), 함수의 재귀 호출은 시스템 스택을 사용하므로 스택 자료구조를 사용한 것으로 간주
        - 전위 순회 - 노드 방문을 첫번째(print())로 하고 재귀 왼쪽, 재귀 오른쪽 순서로 순회
        - 중위 순회
        - 후위 순회
        - 레벨 순회
        - 스레드 이진트리
    - 이진힙
        - 최소힙 - 가장 작은 값이 최상위 노드에 오도록 구성(자신의 부모노드와 비교해서 자신이 작으면 부모노드와 스와핑
        - 최대힙 - 최소힙의 반대
    - 이진탐색 - 1차원 리스트에 데이터가 정렬되어있을 때 주어진 데이터를 효율적으로 찾는 알고리즘
    - 이진탐색트리 - 이진탐색을 트리구조로 접목시킨 자료구조
        - AVL 트리 - 왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이가 1을 넘지 않는 이진탐색트리, 회전연산(LL, RR, RL, LR)
        - 2-3 트리, 2-3-4 트리 - 내부노드의 차수가 2, 3, 4 인 균형 탐색트리, 부모 노드 1에 자식 노드가 최대 4
        - 레드블랙트리 - 노드에 색을 부여, 좌편향 레드블랙 트리 발생 가능성, 반드시 제한된 시간 내에 연산이 수행되어야 하는 경우에 매우 적합한 자료구조
        - B-트리 - 노드에 수백에서 수천 개의 키를 저장하여 트리의 높이를 낮춤, 레벨이 낮을수록 검색, 삽입 등의 시간은 줄어듬
            - B-트리, B+-트리는 대용량의 데이터를 저장하고 유지하는 다양한 데이터베이스 시스템의 기본 자료 구조
                - 상용 데이터베이스인 오라클, DB2, PostgreSQL 에서 사용됨
- 그래프

- 해시 테이블(선형...?) - 클러스터 현상 = Clustering = 군집화 현상

- 
    - 개방 주소 방식: 1인 1실 개념(하나의 해시테이블(인덱스)당 하나의 값)
        - 선형 조사 - 1차 군집화 현상 발생
        - 이차 조사 - 2차 군집화 현상 발생
        - 랜덤 조사 - 3차 군집화 현상 발생
        - 이중 해싱 - 위의 조사 방식보다 군집화 현상 발생할 가능성 낮음
    - 폐쇄 주소 방식: 다인 1실 개념(해시값이 뽑히면 그 해시테이블(인덱스)에 집어넣음)
        - 체이닝 - 연결리스트로 구현되어 레퍼런스가 차지하는 공간이 추가로 필요, 그러나 개방주소방식처럼 해시테이블의 empty 원소를 찾는 오버헤드가 없고, 군집화 현상이 없어 실제로 가장 많이 활용되는 해시 방법
        - 기타해싱(1) - 2-방향 체이닝: 2개의 해시함수로 계산된 두 체인을 검사해서 짧은 체인에 새 항목을 삽입
        - 기타해싱(2) - 뻐꾸기 해싱: 2개의 해시함수와 각 함수에 대응되는 해시테이블을 이용해서 충돌이 발생하면 그 곳에 있는 키를 쫓아냄..
            - 2개의 해시함수, 2개의 해시테이블
        
    - 재해시: 해시테이블에 원소가 적으면 비효율적이다. 그렇기 때문에 해시테이블을 새로 만들어 모든 키들을 새로운 해시테이블에 저장(O(N)시간 소요)

- 정렬
    - (내 방식대로 얘기하자면) 부모 for loop 에서 원소 하나당 자식 for loop 를 모두 순회한다는 개념으로 이해
    - 데이터를 정렬해야 하는 이유
        1. 정렬되어 있지 않으면 순차 탐색 알고리즘만 사용 가능
            - while 문으로 key 값에 해당하는 값을 찾을 때까지 계속 순회
        2. 정렬이 되어 있으면 탐색하기 좋다.
            - 즉, 효율적인 탐색 알고리즘인 이진 탐색 알고리즘 사용이 가능
                - 43억개의 정렬 데이터를 최악의 경우 32회만 비교해서 값을 찾을 수 있음
        3. 결론적으로 무한에 가까운 DB 를 미리 정렬해놓으면 약속된 경로(노드 등)로 찾아가기 때문에 검색 속도가 많이 향상
        4. 정렬 알고리즘은 하나만 쓰이는 것이 아니라 정렬 알고리즘들을 섞어서 쓸 수도 있다..그렇다고 함

    - 선택정렬
        - 리스트의 첫번째 인덱스와 나머지 인덱스 값들을 모두 비교해서 가장 작은 값을 왼쪽에 정렬
        - 리스트의 두번째 인덱스와 나머지 인덱스 값들을 모두 비교해서 두번째로 작은 값을 왼쪽에 정렬
        - 다른 알고리즘에 비해 효율성 측면에서 떨어지기 때문에 비추하는 알고리즘이라고 함
        
    - 삽입정렬
        - 현재 인덱스를 기준으로 왼쪽의(step=-1) 값들을 비교하여 현재 포인터의 인덱스가 작으면 해당 인덱스의 값과 스와핑
            - 현재 원소를 앞부분에 삽입하기 위해 이웃하는 원소들끼리 비교하며 한 자리씩 이동하는 단점이 있음
        - 입력에 민감한 알고리즘으로 이미 데이터가 정렬되어 있으면 연산시간이 오래 걸리지 않아 괜찮은 알고리즘이라고 함
        - 실제 응용에서 이미 정렬된 파일의 뒷부분에 소량의 신규 데이터를 추가하여 정렬하는 경우가 종종 발생하는데 이때 다른 알고리즘들보다 더 우수한 성능을 보여줌
        - 알고리즘도 매우 간단한 편이기에 합병정렬, 퀵정렬과 함께 사용되어 실질적으로 보다 빠른 성능에 도움을 줌
    
    
